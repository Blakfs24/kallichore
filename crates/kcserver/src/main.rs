//
// main.rs
//
// Copyright (C) 2024 Posit Software, PBC. All rights reserved.
//
//

//! Main binary entry point for openapi_client implementation.

#![allow(missing_docs)]

use clap::{command, Parser};

mod client_session;
use rand::Rng;
mod connection_file;
mod error;
mod execution_queue;
mod heartbeat;
mod jupyter_messages;
mod kernel_connection;
mod kernel_session;
mod kernel_state;
mod server;
mod wire_message;
mod wire_message_header;
mod zmq_ws_proxy;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// The port to bind the server to
    #[arg(short, long, default_value_t = 8182)]
    port: u16,

    /// The path to a file containing the authentication token, or the special
    /// string "none" to disable authentication. If omitted, a random token will
    /// be generated.
    #[arg(short, long)]
    token: Option<String>,
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
#[tokio::main]
async fn main() {
    env_logger::init();

    // Parse command line arguments
    let args = Args::parse();

    // Check if the port is already in use
    if !portpicker::is_free_tcp(args.port) {
        log::error!("Port {} is already in use", args.port);
        std::process::exit(1);
    }

    // See if a token file was provided
    let token = match args.token {
        Some(ref token) => {
            if token == "none" {
                log::warn!("Authentication was disabled with --token none.");
                None
            } else {
                match std::fs::read_to_string(token) {
                    Ok(token) => {
                        // Trim the whitespace from the token
                        let token = token.trim();

                        // Ensure the token isn't longer than 64 characters;
                        // this needs to fit in an HTTP header
                        if token.len() > 64 {
                            log::error!("Auth token is too long (max 64 characters)");
                            std::process::exit(1);
                        }

                        // Attempt to delete the file after reading it; since
                        // the path to the file is visible in the process list,
                        // this is a security measure
                        if let Err(e) = std::fs::remove_file(token) {
                            log::warn!("Failed to delete token file: {}", e);
                        }

                        log::trace!("Using auth token from file");
                        Some(token.to_string())
                    }
                    Err(e) => {
                        log::error!("Failed to read token file: {}", e);
                        std::process::exit(1);
                    }
                }
            }
        }
        None => {
            // Generate a random token
            let mut rng = rand::thread_rng();
            let mut hex_string = String::with_capacity(32);

            for _ in 0..8 {
                let byte: u8 = rng.gen();
                hex_string.push_str(&format!("{:02x}", byte));
            }

            // Log the generated token for debugging purposes
            log::info!("Generated random auth token: {}", hex_string);

            Some(hex_string)
        }
    };

    // Start the server
    let addr = format!("127.0.0.1:{}", args.port);

    log::info!("Starting Kallichore server at {}", addr);
    server::create(&addr, token).await;
}
